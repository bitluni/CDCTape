<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>WebSerial Scope</title>
  <style>
    body {
      font-family: sans-serif;
      background: #111;
      color: white;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #555;
      background: black;
    }
    button {
      margin: 5px;
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>

  <h1>WebSerial Scope</h1>
  <button onclick="connectSerial()">Connect</button>
  <div>
    <button onclick="sendByte(1)">Stop</button>
    <button onclick="sendByte(2)">Play</button>
    <button onclick="sendByte(3)">Rew</button>
    <button onclick="sendByte(4)">FF</button>
    <button onclick="sendByte(5)">Record</button>
    <button onclick="sendByte(6)">Rec Test</button>
    <button onclick="sendByte(7)">Read ADC</button>
    <button onclick="sendByte(9)">Read Test</button>
    <button onclick="decode(findSync())">Sync & Decode</button>
	<input id="start" type="range" min="0" max="32000" value="0" oninput="decode(this.value * 1);">
  </div>
  <canvas id="scope" width="1600" height="200"></canvas>

  <script>
    let port;
    let writer;
    let reader;
    let canvas = document.getElementById('scope');
    let ctx = canvas.getContext('2d');
	let raw = new Uint16Array(40000).fill(0);
	let rawPos = 0;
    let buffer = new Uint8Array(canvas.width).fill(0);

    async function connectSerial() {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });

        writer = port.writable.getWriter();
        reader = port.readable.getReader();

        readLoop();
      } catch (err) {
        alert('Serial connection failed: ' + err);
      }
    }

    function sendByte(byte) {
      if (!writer) return;
      writer.write(new Uint8Array([byte]));
    }

	function plot(value)
	{
		buffer.copyWithin(0, 1);
		buffer[buffer.length - 1] = value;
	}


	function decodeByteOld(start)
	{
		let b = 0;
		let pow = 0x7fffffff;
		for(let i = 0; i < 10; i++)
		{
			let p = start + i * 64;
			let pow1 = raw[p + 8] - raw[p + 24] + raw[p + 40] - raw[p + 56];
			let pow0 = raw[p + 4] - raw[start + 12] + raw[p + 20] - raw[start + 28] + 
						raw[p + 36] - raw[start + 44] + raw[p + 52] - raw[start + 60];
			/*
			let pow1 = raw[p + 4] + raw[p + 8] + raw[p + 12] - raw[p + 20] - raw[p + 24] - raw[p + 28];
			let pow0 = raw[p + 2] + raw[p + 4] + raw[p + 6] - raw[p + 10] - raw[p + 12] - raw[p + 14]
					+ raw[p + 18] + raw[p + 20] + raw[p + 22] - raw[p + 26] - raw[p + 28] - raw[p + 30];
			*/
			pow1 *= pow1;
			pow0 *= pow0;
			if(pow0 < pow1)
			{
				b |= 1 << i;
				//pow += pow1;
				pow = pow < pow1 ? pow : pow1;
			}
			else
			{
				//pow += pow0;
				pow = pow < pow0 ? pow : pow0;
			}
		}
		return [b, pow];
	}

	const wavesPerBit = 1;
	const samplesPerWave = 32;

	function decodeByte(start, startStopBits)
	{
		let b = 0;
		let pow = 0x7fffffff;
		const bitsPerWord = startStopBits ? 10 : 8;
		const samplesPerBit = samplesPerWave * wavesPerBit;
		const samplesPerWord = samplesPerBit * bitsPerWord;
		const samplesPerWaveDiv2 = samplesPerWave >> 1;
		const samplesPerWaveDiv4 = samplesPerWave >> 2;

		for(let i = 0; i < bitsPerWord; i++)
		{
			let p = start + i * samplesPerBit;
			let pow0 = 0;
			let pow1 = 0;
			//matching square wave instead of sine
			for(let k = 0; k < wavesPerBit; k++)
			{
				for(let j = 0; j < samplesPerWaveDiv2; j++)
					pow1 += raw[p + k * wavesPerBit + j] - 
							raw[p + k * wavesPerBit + j + samplesPerWaveDiv2];
				for(let j = 0; j < samplesPerWaveDiv4; j++)
					pow0 += raw[p + k * wavesPerBit + j] - 
							raw[p + k * wavesPerBit + j + samplesPerWaveDiv4] +
							raw[p + k * wavesPerBit + j + samplesPerWaveDiv2] - 
							raw[p + k * wavesPerBit + j + samplesPerWaveDiv2 + samplesPerWaveDiv4];
			}

			/*for(let j = 0; j < 64; j++)
			{
				pow1 += Math.sin(Math.PI * 2 / 32 * j) * raw[p + j];
				pow0 += Math.sin(Math.PI * 4 / 32 * j) * raw[p + j];
			}*/
			if(pow0 < pow1)
			{
				b |= 1 << i;
				//pow += pow1;
				pow = pow < pow1 ? pow : pow1;
			}
			else
			{
				//pow += pow0;
				pow = pow < pow0 ? pow : pow0;
			}
		}
		return [b, pow];
	}

	function findSync(startStopBits = false)
	{
		const thresholdPower = 400;
		const syncWord = startStopBits ? 0b0010100111 : 0b01010011;
		let syncPow = 0;
		for(let i = 0; i < rawPos; i++)
		{
			const [b, pow] = decodeByte(i, startStopBits);
			if(b == syncWord && pow > thresholdPower)
			{
				if(syncPow < pow)
					syncPow = pow;
				else
				{
					byteSamples = 1;
					i--;
					console.log("sync pos " + i + " pow "+ pow);
					document.getElementById("start").value = i;
					return i;
				}
			}
		}
		return 0;
	}

	function getByteFramePower(p)
	{
		//only with start stop bits
		let pow = 0;
		const wavesPerBit = 2;
		const samplesPerBit = 32 * wavesPerBit;
		for(let j = 0; j < samplesPerBit; j++)
		{
			pow += Math.sin(Math.PI * 2 / 32 * j) * raw[p + j]; //matching leading 1
			pow += Math.sin(Math.PI * 4 / 32 * j + samplesPerBit * 9) * raw[p + j];	//mathing trailing 0
		}
		return pow;
	}

	function decode(start, startStopBits = false)
	{
		console.clear();
		console.log("sync power: " + decodeByte(start, startStopBits));
		let bytesDecoded = 0;
		const bitsPerWord = startStopBits ? 10 : 8;
		const samplesPerBit = samplesPerWave * wavesPerBit;
		const samplesPerWord = samplesPerBit * bitsPerWord;
		const syncCorrection = 4;
		for(let j = 0; j < 1600; j++)
			if((j % samplesPerBit) == 0 && j >= samplesPerBit)
				plot(255);
			else
				plot(raw[start - samplesPerBit + j]);
		start += samplesPerWord; //skip sync byte

		for(let i = start; i < rawPos; i += samplesPerWord)
		{
			let maxP = 0;
			let maxJ = 0;
			let maxB = 0;
			for(let j = -syncCorrection; j <= syncCorrection; j++)
			{
				//let p = getByteFramePower(i + j);
				const [b, p] = decodeByte(i + j, startStopBits);
				if(p > maxP)
				{
					maxP = p;
					maxJ = j;
					maxB = b;
				}
			}
			i += maxJ;
			const b = startStopBits? (maxB >> 1) & 0xff : maxB;
			const pow = maxP;
			if(pow <= 0)
			{
				console.log("lost sync " + pow);
				return;
			}
			console.log(b + " " + pow + " " + maxP);
			//plot((b >> 1) & 0xff);
			bytesDecoded++;
		}
	}

	let dcOffset = 128;
	let filterState = 0;
	function filter(v)
	{
		const center = 128;
		const amp = 10;
		if(filterState == 0 && v > dcOffset + amp)
			filterState = 1;
		else
		if(filterState == 1 && v < dcOffset - amp)
			filterState = 0;
		dcOffset = dcOffset * 0.98 + v * 0.02;
		return v - dcOffset + 128;//filterState * 255;
	}

    async function readLoop() {
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            for (let i = 0; i < value.length; i++) 
			{
				if(rawPos == 40000) rawPos = 0;
				raw[rawPos++] = filter(value[i]);
              plot(value[i]);
            }
          }
        }
      } catch (error) {
        console.error('Read error:', error);
      } finally {
        reader.releaseLock();
      }
    }

    function drawScope() {
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = 'lime';
      ctx.beginPath();
      for (let x = 0; x < buffer.length; x++) {
        let y = canvas.height - (buffer[x] / 255) * canvas.height;
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      requestAnimationFrame(drawScope);
    }

    drawScope();
  </script>
</body>
</html>
